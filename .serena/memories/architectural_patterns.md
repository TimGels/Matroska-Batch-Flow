# Architectural Patterns

## Two-Stage Track Configuration Architecture

The application uses a **two-stage architecture** for track configuration that cleanly separates mechanical data collection from business logic presentation:

### Stage 1: Mechanical Per-File Population
- **Responsibility**: `BatchTrackCountSynchronizer`
- **Purpose**: Copy exact scanned values from MediaInfo to per-file configurations
- **Key Principle**: No business logic - just direct data transformation
- Populates: `IBatchConfiguration.FileConfigurations[path]` for each file

### Stage 2: Smart Global UI Population  
- **Responsibility**: `IFileProcessingRule` implementations
- **Purpose**: Analyze per-file data and determine smart defaults for global UI
- **Key Principle**: Apply business logic to decide what users see
- Populates: `IBatchConfiguration` global collections (AudioTracks, VideoTracks, TextTracks)

### Benefits
1. **Separation of Concerns**: Data collection vs. business decisions
2. **No Duplication**: Scanned data copied once by synchronizer
3. **Easy Testing**: Test data transformation and business logic separately
4. **Maintainability**: Change data sources or UI logic independently

### Command Generation Pattern
Commands are generated by comparing:
- **Global configuration** (what user sees/edits in UI)
- **Per-file configuration** (actual scanned values from MediaInfo)
- Commands generated only when global differs from per-file

See [two-stage-architecture.md](two-stage-architecture.md) for complete documentation.

## Configuration Management

### Two-Tier Configuration Model
The application maintains two distinct levels of track configuration:

1. **Global Configuration** (`IBatchConfiguration`)
   - Single instance containing UI-visible collections
   - Properties: `AudioTracks`, `VideoTracks`, `TextTracks`
   - Purpose: What the user sees and edits in the UI
   - Scope: Batch-wide defaults

2. **Per-File Configuration** (`FileTrackConfiguration`)
   - Stored in `IBatchConfiguration.FileConfigurations` dictionary
   - Key: Absolute file path
   - Properties: `AudioTracks`, `VideoTracks`, `TextTracks` (same structure as global)
   - Purpose: Actual scanned values for each file
   - Scope: Individual file metadata

### Configuration Flow
```
Scan File → Synchronizer populates per-file config → 
Rules populate global config → UI displays global config → 
User edits global config → Command generator compares global vs per-file → 
Generate mkvpropedit commands for differences
```

## Service Architecture

### Dependency Injection
- All services registered as **Singletons** via `IServiceCollection`
- Host built using `IHostBuilder` pattern
- Configuration loaded from `appsettings.json`

### Core Services
- **IBatchConfiguration**: Central configuration state
- **ILanguageProvider**: Matroska language code resolution
- **IFileProcessingRule**: Plugin-style rules for processing scanned files
- **FileProcessingEngine**: Orchestrates rule execution
- **BatchTrackCountSynchronizer**: Stage 1 per-file population

## MVVM Architecture (Uno Platform)

### View-ViewModel Separation
- Views: XAML UI definitions
- ViewModels: Presentation logic and state management
- Models: Domain entities and business logic (Core project)

### ViewModel Patterns
- `TrackViewModelBase`: Base class for track-specific ViewModels
- Method: `UpdateBatchConfigTrackProperty` - synchronizes global and per-file configurations when user edits UI
- Pattern: ViewModels update both global (for UI) and per-file (for command generation) simultaneously

## Testing Strategy

### Unit Tests
- **Core.UnitTests**: Test business logic, models, and services
- **Uno.UnitTests**: Test ViewModel logic and UI behavior
- Framework: xUnit with NSubstitute for mocking

### Integration Tests
- **Uno.IntegrationTests**: End-to-end workflow testing
- Validate: File scanning → rule processing → command generation

### Test Organization
- One test class per production class
- Test naming: `MethodName_Scenario_ExpectedResult`
- Parameterized tests for multiple scenarios

## Project Structure

### Solution Organization
```
MatroskaBatchFlow.sln (root)
├── src/
│   ├── MatroskaBatchFlow.Core/        # Business logic, domain models, services
│   ├── MatroskaBatchFlow.Console/     # CLI interface (legacy/future)
│   └── MatroskaBatchFlow.Uno/         # Cross-platform GUI (WinUI3/Uno Platform)
└── tests/
    ├── MatroskaBatchFlow.Core.UnitTests/
    ├── MatroskaBatchFlow.Uno.UnitTests/
    └── MatroskaBatchFlow.Uno.IntegrationTests/
```

### Core vs Uno Separation
- **Core**: Platform-agnostic business logic
- **Uno**: UI-specific presentation layer
- Communication: Core services injected into Uno ViewModels

## Processing Pipeline

### File Processing Sequence
1. User adds files to batch
2. MediaInfo scans each file
3. `BatchTrackCountSynchronizer` creates per-file configurations (Stage 1)
4. `FileProcessingEngine` applies all `IFileProcessingRule` implementations (Stage 2)
5. Global UI collections populated with smart defaults
6. User can view/edit global configuration
7. Command generator compares global vs per-file to produce mkvpropedit commands

### Extensibility
- New rules: Implement `IFileProcessingRule` interface
- Automatic discovery: All rules registered in DI container
- Sequential execution: Rules applied in registration order
